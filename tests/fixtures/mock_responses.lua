-- Test fixtures for OpenAI API responses
-- Provides consistent mock data for testing API interactions

local M = {}

---Successful theme generation response
M.successful_response = {
  status = 200,
  body = vim.json.encode({
    choices = {
      {
        message = {
          content = vim.json.encode({
            name = "test-theme",
            description = "A beautiful test theme generated by AI",
            colors = {
              bg = "#1a1b26",
              fg = "#c0caf5",
              bg_sidebar = "#1a1b26",
              bg_float = "#24283b",
              bg_statusline = "#1f2335",
              red = "#f7768e",
              orange = "#ff9e64",
              yellow = "#e0af68",
              green = "#9ece6a",
              cyan = "#73daca",
              blue = "#7aa2f7",
              purple = "#bb9af7",
              magenta = "#d18616",
              comment = "#565f89",
              selection = "#33467c",
              cursor = "#c0caf5"
            }
          })
        }
      }
    }
  })
}

---Error responses for different scenarios
M.error_responses = {
  -- Invalid API key
  invalid_api_key = {
    status = 401,
    body = vim.json.encode({
      error = {
        message = "Invalid API key provided",
        type = "invalid_request_error",
        code = "invalid_api_key"
      }
    })
  },

  -- Rate limited
  rate_limited = {
    status = 429,
    body = vim.json.encode({
      error = {
        message = "You exceeded your current quota, please check your plan and billing details",
        type = "insufficient_quota"
      }
    })
  },

  -- Model not found
  model_not_found = {
    status = 404,
    body = vim.json.encode({
      error = {
        message = "Model 'invalid-model' not found",
        type = "invalid_request_error",
        code = "model_not_found"
      }
    })
  },

  -- Server error
  server_error = {
    status = 500,
    body = vim.json.encode({
      error = {
        message = "Internal server error",
        type = "server_error"
      }
    })
  },

  -- Service unavailable
  service_unavailable = {
    status = 503,
    body = vim.json.encode({
      error = {
        message = "Service temporarily unavailable",
        type = "service_unavailable"
      }
    })
  }
}

---Malformed responses for testing error handling
M.malformed_responses = {
  -- Invalid JSON
  invalid_json = {
    status = 200,
    body = "invalid json content"
  },

  -- Incomplete JSON
  incomplete_json = {
    status = 200,
    body = '{"choices": [{"message": {"content": "incomplete'
  },

  -- Empty response
  empty_response = {
    status = 200,
    body = ""
  },

  -- Null response
  null_response = {
    status = 200,
    body = "null"
  },

  -- Missing choices
  missing_choices = {
    status = 200,
    body = vim.json.encode({
      no_choices_here: []
    })
  },

  -- Empty choices array
  empty_choices = {
    status = 200,
    body = vim.json.encode({
      choices = []
    })
  },

  -- Choice without message
  choice_without_message = {
    status = 200,
    body = vim.json.encode({
      choices = [{}]
    })
  },

  -- Message without content
  message_without_content = {
    status = 200,
    body = vim.json.encode({
      choices = [{
        message: {}
      }]
    })
  },

  -- Invalid content type
  invalid_content_type = {
    status = 200,
    body = vim.json.encode({
      choices = [{
        message: {
          content = 123
        }
      }]
    })
  },

  -- Invalid JSON in content
  invalid_content_json = {
    status = 200,
    body = vim.json.encode({
      choices = [{
        message: {
          content: "invalid json in content"
        }
      }]
    })
  }
}

---Network-related errors
M.network_errors = {
  -- Connection timeout
  timeout = {
    status = 0,
    body = nil,
    error = "timeout"
  },

  -- Connection refused
  connection_refused = {
    status = 0,
    body = nil,
    error = "connection refused"
  },

  -- DNS resolution failed
  dns_failed = {
    status = 0,
    body = nil,
    error = "dns resolution failed"
  },

  -- SSL certificate error
  ssl_error = {
    status = 0,
    body = nil,
    error = "ssl certificate error"
  }
}

---Generate a custom successful response
---@param theme_name string Name of the theme
---@param theme_description string Description of the theme
---@param base_color string Base hex color for theme generation
---@return table Response object
M.generate_success_response = function(theme_name, theme_description, base_color)
  local r = tonumber(base_color:sub(2, 3), 16)
  local g = tonumber(base_color:sub(4, 5), 16)
  local b = tonumber(base_color:sub(6, 7), 16)

  local function vary_color(factor)
    local nr = math.min(255, math.max(0, math.floor(r * factor)))
    local ng = math.min(255, math.max(0, math.floor(g * factor)))
    local nb = math.min(255, math.max(0, math.floor(b * factor)))
    return string.format("#%02x%02x%02x", nr, ng, nb)
  end

  return {
    status = 200,
    body = vim.json.encode({
      choices = {
        {
          message = {
            content = vim.json.encode({
              name = theme_name,
              description = theme_description,
              colors = {
                bg = base_color,
                fg = vary_color(3),
                bg_sidebar = vary_color(0.8),
                bg_float = vary_color(1.2),
                bg_statusline = vary_color(0.9),
                red = "#ff0000",
                orange = "#ff8800",
                yellow = "#ffff00",
                green = "#00ff00",
                cyan = "#00ffff",
                blue = "#0000ff",
                purple = "#ff00ff",
                magenta = "#ff0088",
                comment = vary_color(0.5),
                selection = vary_color(1.5),
                cursor = "#ffffff"
              }
            })
          }
        }
      }
    })
  }
end

---Generate an error response
---@param status number HTTP status code
---@param error_message string Error message
---@param error_type string Error type
---@return table Response object
M.generate_error_response = function(status, error_message, error_type)
  return {
    status = status,
    body = vim.json.encode({
      error = {
        message = error_message,
        type = error_type or "error"
      }
    })
  }
end

---Collection of all response types for comprehensive testing
M.all_responses = {
  successful = M.successful_response,
  errors = M.error_responses,
  malformed = M.malformed_responses,
  network = M.network_errors
}

---Create a mock curl function that returns specific responses
---@param response table Response to return
---@return function Mock curl function
M.create_mock_curl = function(response)
  return function(url, options)
    -- Simulate network delay for testing
    if response.delay then
      vim.defer_fn(function()
        if response.error then
          -- Simulate network error
          options.callback(nil, response.error)
        else
          options.callback(response)
        end
      end, response.delay)
    else
      if response.error then
        -- Simulate network error
        options.callback(nil, response.error)
      else
        options.callback(response)
      end
    end
  end
end

---Create a sequence of responses for testing multiple API calls
---@param responses table List of responses to return in sequence
---@return function Mock curl function that cycles through responses
M.create_sequential_mock_curl = function(responses)
  local call_count = 0
  return function(url, options)
    call_count = call_count + 1
    local response = responses[math.min(call_count, #responses)]

    if response.error then
      options.callback(nil, response.error)
    else
      options.callback(response)
    end
  end
end

---Create a mock curl function that conditionally returns responses
---@param condition_func Function that determines which response to return
---@param success_response Response to return on success
---@param error_response Response to return on error
---@return function Mock curl function
M.create_conditional_mock_curl = function(condition_func, success_response, error_response)
  return function(url, options)
    -- Extract request data for condition checking
    local request_data = vim.json.decode(options.body)

    if condition_func(request_data) then
      options.callback(success_response)
    else
      options.callback(error_response)
    end
  end
end

return M